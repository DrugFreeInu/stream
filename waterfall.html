<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Waterfall</title>

<style>
  html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: transparent;
  }
  canvas {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }
</style>
</head>

<body>
<canvas id="fx"></canvas>

<script>
const canvas = document.getElementById("fx");
const ctx = canvas.getContext("2d", { alpha: true });

/* =========================
   SHARED CONTRACT
========================= */
const WATER_HEIGHT_RATIO = 0.3;
const HORIZON_THICKNESS = 2;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
addEventListener("resize", resize);

function horizonY() {
  return Math.floor(canvas.height * (1 - WATER_HEIGHT_RATIO));
}

/* =========================
   WATERFALL (vertical strands)
========================= */
const STRAND_COUNT = 90;
const strands = [];

function columnWidth() {
  return Math.min(260, canvas.width * 0.22);
}

function centerX() {
  return canvas.width * 0.5;
}

for (let i = 0; i < STRAND_COUNT; i++) {
  strands.push({
    xOff: (Math.random() - 0.5) * columnWidth(),
    y: -Math.random() * 600,
    len: 120 + Math.random() * 380,
    amp: 1 + Math.random() * 3,
    freq: 0.006 + Math.random() * 0.010,
    phase: Math.random() * Math.PI * 2,
    thickness: Math.random() < 0.9 ? 1 : 2,
    alpha: 0.06 + Math.random() * 0.18,
    speed: 1.0 + Math.random() * 2.0
  });
}

/* =========================
   ANIMATE
========================= */
let t = 0;
let last = performance.now();

function draw(now) {
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.lineCap = "round";

  const hy = horizonY();

  /* ---- Draw waterfall ABOVE horizon only ---- */
  ctx.save();
  ctx.beginPath();
  ctx.rect(0, 0, canvas.width, Math.max(0, hy - HORIZON_THICKNESS));
  ctx.clip();

  for (const s of strands) {
    ctx.beginPath();
    ctx.lineWidth = s.thickness;
    ctx.strokeStyle = `rgba(255,255,255,${s.alpha})`;

    const yTop = s.y - s.len;
    const yBot = s.y;

    let started = false;

    for (let y = yTop; y <= yBot; y += 12) {
      const x =
        centerX() +
        s.xOff +
        Math.sin(y * s.freq + s.phase + t) * s.amp;

      if (!started) {
        ctx.moveTo(x, y);
        started = true;
      } else {
        ctx.lineTo(x, y);
      }
    }

    ctx.stroke();

    // gravity
    s.y += s.speed;

    // reset cleanly at horizon (no interaction)
    if (s.y >= hy - HORIZON_THICKNESS) {
      s.y = -Math.random() * 400;
      s.len = 120 + Math.random() * 380;
      s.xOff = (Math.random() - 0.5) * columnWidth();
      s.phase = Math.random() * Math.PI * 2;
    }
  }

  ctx.restore();

  t += 0.9 * dt;
  requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>
</body>
</html>
